// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AcceptContract invokes accept-contract operation.
	//
	// Accept a contract by ID.
	// You can only accept contracts that were offered to you, were not accepted yet, and whose deadlines
	// has not passed yet.
	//
	// POST /my/contracts/{contractId}/accept
	AcceptContract(ctx context.Context, params AcceptContractParams) (*AcceptContractOK, error)
	// CreateChart invokes create-chart operation.
	//
	// Command a ship to chart the waypoint at its current location.
	// Most waypoints in the universe are uncharted by default. These waypoints have their traits hidden
	// until they have been charted by a ship.
	// Charting a waypoint will record your agent as the one who created the chart, and all other agents
	// would also be able to see the waypoint's traits.
	//
	// POST /my/ships/{shipSymbol}/chart
	CreateChart(ctx context.Context, params CreateChartParams) (*CreateChartCreated, error)
	// CreateShipShipScan invokes create-ship-ship-scan operation.
	//
	// Scan for nearby ships, retrieving information for all ships in range.
	// Requires a ship to have the `Sensor Array` mount installed to use.
	// The ship will enter a cooldown after using this function, during which it cannot execute certain
	// actions.
	//
	// POST /my/ships/{shipSymbol}/scan/ships
	CreateShipShipScan(ctx context.Context, params CreateShipShipScanParams) (*CreateShipShipScanCreated, error)
	// CreateShipSystemScan invokes create-ship-system-scan operation.
	//
	// Scan for nearby systems, retrieving information on the systems' distance from the ship and their
	// waypoints. Requires a ship to have the `Sensor Array` mount installed to use.
	// The ship will enter a cooldown after using this function, during which it cannot execute certain
	// actions.
	//
	// POST /my/ships/{shipSymbol}/scan/systems
	CreateShipSystemScan(ctx context.Context, params CreateShipSystemScanParams) (*CreateShipSystemScanCreated, error)
	// CreateShipWaypointScan invokes create-ship-waypoint-scan operation.
	//
	// Scan for nearby waypoints, retrieving detailed information on each waypoint in range. Scanning
	// uncharted waypoints will allow you to ignore their uncharted state and will list the waypoints'
	// traits.
	// Requires a ship to have the `Sensor Array` mount installed to use.
	// The ship will enter a cooldown after using this function, during which it cannot execute certain
	// actions.
	//
	// POST /my/ships/{shipSymbol}/scan/waypoints
	CreateShipWaypointScan(ctx context.Context, params CreateShipWaypointScanParams) (*CreateShipWaypointScanCreated, error)
	// CreateSurvey invokes create-survey operation.
	//
	// Create surveys on a waypoint that can be extracted such as asteroid fields. A survey focuses on
	// specific types of deposits from the extracted location. When ships extract using this survey, they
	// are guaranteed to procure a high amount of one of the goods in the survey.
	// In order to use a survey, send the entire survey details in the body of the extract request.
	// Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a
	// higher chance of extracting that resource.
	// Your ship will enter a cooldown after surveying in which it is unable to perform certain actions.
	// Surveys will eventually expire after a period of time or will be exhausted after being extracted
	// several times based on the survey's size. Multiple ships can use the same survey for extraction.
	// A ship must have the `Surveyor` mount installed in order to use this function.
	//
	// POST /my/ships/{shipSymbol}/survey
	CreateSurvey(ctx context.Context, params CreateSurveyParams) (*CreateSurveyCreated, error)
	// DeliverContract invokes deliver-contract operation.
	//
	// Deliver cargo to a contract.
	// In order to use this API, a ship must be at the delivery location (denoted in the delivery terms
	// as `destinationSymbol` of a contract) and must have a number of units of a good required by this
	// contract in its cargo.
	// Cargo that was delivered will be removed from the ship's cargo.
	//
	// POST /my/contracts/{contractId}/deliver
	DeliverContract(ctx context.Context, request OptDeliverContractReq, params DeliverContractParams) (*DeliverContractOK, error)
	// DockShip invokes dock-ship operation.
	//
	// Attempt to dock your ship at its current location. Docking will only succeed if your ship is
	// capable of docking at the time of the request.
	// Docked ships can access elements in their current location, such as the market or a shipyard, but
	// cannot do actions that require the ship to be above surface such as navigating or extracting.
	// The endpoint is idempotent - successive calls will succeed even if the ship is already docked.
	//
	// POST /my/ships/{shipSymbol}/dock
	DockShip(ctx context.Context, params DockShipParams) (*DockShipOK, error)
	// ExtractResources invokes extract-resources operation.
	//
	// Extract resources from a waypoint that can be extracted, such as asteroid fields, into your ship.
	// Send an optional survey as the payload to target specific yields.
	// The ship must be in orbit to be able to extract and must have mining equipments installed that can
	// extract goods, such as the `Gas Siphon` mount for gas-based goods or `Mining Laser` mount for
	// ore-based goods.
	// The survey property is now deprecated. See the `extract/survey` endpoint for more details.
	//
	// POST /my/ships/{shipSymbol}/extract
	ExtractResources(ctx context.Context, request OptExtractResourcesReq, params ExtractResourcesParams) (*ExtractResourcesCreated, error)
	// ExtractResourcesWithSurvey invokes extract-resources-with-survey operation.
	//
	// Use a survey when extracting resources from a waypoint. This endpoint requires a survey as the
	// payload, which allows your ship to extract specific yields.
	// Send the full survey object as the payload which will be validated according to the signature. If
	// the signature is invalid, or any properties of the survey are changed, the request will fail.
	//
	// POST /my/ships/{shipSymbol}/extract/survey
	ExtractResourcesWithSurvey(ctx context.Context, request OptSurvey, params ExtractResourcesWithSurveyParams) (*ExtractResourcesWithSurveyCreated, error)
	// FulfillContract invokes fulfill-contract operation.
	//
	// Fulfill a contract. Can only be used on contracts that have all of their delivery terms fulfilled.
	//
	// POST /my/contracts/{contractId}/fulfill
	FulfillContract(ctx context.Context, params FulfillContractParams) (*FulfillContractOK, error)
	// GetAgent invokes get-agent operation.
	//
	// Fetch agent details.
	//
	// GET /agents/{agentSymbol}
	GetAgent(ctx context.Context, params GetAgentParams) (*GetAgentOK, error)
	// GetAgents invokes get-agents operation.
	//
	// Fetch agents details.
	//
	// GET /agents
	GetAgents(ctx context.Context, params GetAgentsParams) (*GetAgentsOK, error)
	// GetConstruction invokes get-construction operation.
	//
	// Get construction details for a waypoint. Requires a waypoint with a property of
	// `isUnderConstruction` to be true.
	//
	// GET /systems/{systemSymbol}/waypoints/{waypointSymbol}/construction
	GetConstruction(ctx context.Context, params GetConstructionParams) (*GetConstructionOK, error)
	// GetContract invokes get-contract operation.
	//
	// Get the details of a contract by ID.
	//
	// GET /my/contracts/{contractId}
	GetContract(ctx context.Context, params GetContractParams) (*GetContractOK, error)
	// GetContracts invokes get-contracts operation.
	//
	// Return a paginated list of all your contracts.
	//
	// GET /my/contracts
	GetContracts(ctx context.Context, params GetContractsParams) (*GetContractsOK, error)
	// GetFaction invokes get-faction operation.
	//
	// View the details of a faction.
	//
	// GET /factions/{factionSymbol}
	GetFaction(ctx context.Context, params GetFactionParams) (*GetFactionOK, error)
	// GetFactions invokes get-factions operation.
	//
	// Return a paginated list of all the factions in the game.
	//
	// GET /factions
	GetFactions(ctx context.Context, params GetFactionsParams) (*GetFactionsOK, error)
	// GetJumpGate invokes get-jump-gate operation.
	//
	// Get jump gate details for a waypoint. Requires a waypoint of type `JUMP_GATE` to use.
	// Waypoints connected to this jump gate can be.
	//
	// GET /systems/{systemSymbol}/waypoints/{waypointSymbol}/jump-gate
	GetJumpGate(ctx context.Context, params GetJumpGateParams) (*GetJumpGateOK, error)
	// GetMarket invokes get-market operation.
	//
	// Retrieve imports, exports and exchange data from a marketplace. Requires a waypoint that has the
	// `Marketplace` trait to use.
	// Send a ship to the waypoint to access trade good prices and recent transactions. Refer to the
	// [Market Overview page](https://docs.spacetraders.io/game-concepts/markets) to gain better a
	// understanding of the market in the game.
	//
	// GET /systems/{systemSymbol}/waypoints/{waypointSymbol}/market
	GetMarket(ctx context.Context, params GetMarketParams) (*GetMarketOK, error)
	// GetMounts invokes get-mounts operation.
	//
	// Get the mounts installed on a ship.
	//
	// GET /my/ships/{shipSymbol}/mounts
	GetMounts(ctx context.Context, params GetMountsParams) (*GetMountsOK, error)
	// GetMyAgent invokes get-my-agent operation.
	//
	// Fetch your agent's details.
	//
	// GET /my/agent
	GetMyAgent(ctx context.Context) (*GetMyAgentOK, error)
	// GetMyShip invokes get-my-ship operation.
	//
	// Retrieve the details of a ship under your agent's ownership.
	//
	// GET /my/ships/{shipSymbol}
	GetMyShip(ctx context.Context, params GetMyShipParams) (*GetMyShipOK, error)
	// GetMyShipCargo invokes get-my-ship-cargo operation.
	//
	// Retrieve the cargo of a ship under your agent's ownership.
	//
	// GET /my/ships/{shipSymbol}/cargo
	GetMyShipCargo(ctx context.Context, params GetMyShipCargoParams) (*GetMyShipCargoOK, error)
	// GetMyShips invokes get-my-ships operation.
	//
	// Return a paginated list of all of ships under your agent's ownership.
	//
	// GET /my/ships
	GetMyShips(ctx context.Context, params GetMyShipsParams) (*GetMyShipsOK, error)
	// GetRepairShip invokes get-repair-ship operation.
	//
	// Get the cost of repairing a ship.
	//
	// GET /my/ships/{shipSymbol}/repair
	GetRepairShip(ctx context.Context, params GetRepairShipParams) (*GetRepairShipOK, error)
	// GetScrapShip invokes get-scrap-ship operation.
	//
	// Get the amount of value that will be returned when scrapping a ship.
	//
	// GET /my/ships/{shipSymbol}/scrap
	GetScrapShip(ctx context.Context, params GetScrapShipParams) (*GetScrapShipOK, error)
	// GetShipCooldown invokes get-ship-cooldown operation.
	//
	// Retrieve the details of your ship's reactor cooldown. Some actions such as activating your jump
	// drive, scanning, or extracting resources taxes your reactor and results in a cooldown.
	// Your ship cannot perform additional actions until your cooldown has expired. The duration of your
	// cooldown is relative to the power consumption of the related modules or mounts for the action
	// taken.
	// Response returns a 204 status code (no-content) when the ship has no cooldown.
	//
	// GET /my/ships/{shipSymbol}/cooldown
	GetShipCooldown(ctx context.Context, params GetShipCooldownParams) (GetShipCooldownRes, error)
	// GetShipNav invokes get-ship-nav operation.
	//
	// Get the current nav status of a ship.
	//
	// GET /my/ships/{shipSymbol}/nav
	GetShipNav(ctx context.Context, params GetShipNavParams) (*GetShipNavOK, error)
	// GetShipyard invokes get-shipyard operation.
	//
	// Get the shipyard for a waypoint. Requires a waypoint that has the `Shipyard` trait to use. Send a
	// ship to the waypoint to access data on ships that are currently available for purchase and recent
	// transactions.
	//
	// GET /systems/{systemSymbol}/waypoints/{waypointSymbol}/shipyard
	GetShipyard(ctx context.Context, params GetShipyardParams) (*GetShipyardOK, error)
	// GetStatus invokes get-status operation.
	//
	// Return the status of the game server.
	// This also includes a few global elements, such as announcements, server reset dates and
	// leaderboards.
	//
	// GET /
	GetStatus(ctx context.Context) (*GetStatusOK, error)
	// GetSystem invokes get-system operation.
	//
	// Get the details of a system.
	//
	// GET /systems/{systemSymbol}
	GetSystem(ctx context.Context, params GetSystemParams) (*GetSystemOK, error)
	// GetSystemWaypoints invokes get-system-waypoints operation.
	//
	// Return a paginated list of all of the waypoints for a given system.
	// If a waypoint is uncharted, it will return the `Uncharted` trait instead of its actual traits.
	//
	// GET /systems/{systemSymbol}/waypoints
	GetSystemWaypoints(ctx context.Context, params GetSystemWaypointsParams) (*GetSystemWaypointsOK, error)
	// GetSystems invokes get-systems operation.
	//
	// Return a paginated list of all systems.
	//
	// GET /systems
	GetSystems(ctx context.Context, params GetSystemsParams) (*GetSystemsOK, error)
	// GetWaypoint invokes get-waypoint operation.
	//
	// View the details of a waypoint.
	// If the waypoint is uncharted, it will return the 'Uncharted' trait instead of its actual traits.
	//
	// GET /systems/{systemSymbol}/waypoints/{waypointSymbol}
	GetWaypoint(ctx context.Context, params GetWaypointParams) (*GetWaypointOK, error)
	// InstallMount invokes install-mount operation.
	//
	// Install a mount on a ship.
	// In order to install a mount, the ship must be docked and located in a waypoint that has a
	// `Shipyard` trait. The ship also must have the mount to install in its cargo hold.
	// An installation fee will be deduced by the Shipyard for installing the mount on the ship.
	//
	// POST /my/ships/{shipSymbol}/mounts/install
	InstallMount(ctx context.Context, request OptInstallMountReq, params InstallMountParams) (*InstallMountCreated, error)
	// Jettison invokes jettison operation.
	//
	// Jettison cargo from your ship's cargo hold.
	//
	// POST /my/ships/{shipSymbol}/jettison
	Jettison(ctx context.Context, request OptJettisonReq, params JettisonParams) (*JettisonOK, error)
	// JumpShip invokes jump-ship operation.
	//
	// Jump your ship instantly to a target connected waypoint. The ship must be in orbit to execute a
	// jump.
	// A unit of antimatter is purchased and consumed from the market when jumping. The price of
	// antimatter is determined by the market and is subject to change. A ship can only jump to connected
	// waypoints.
	//
	// POST /my/ships/{shipSymbol}/jump
	JumpShip(ctx context.Context, request OptJumpShipReq, params JumpShipParams) (*JumpShipOK, error)
	// NavigateShip invokes navigate-ship operation.
	//
	// Navigate to a target destination. The ship must be in orbit to use this function. The destination
	// waypoint must be within the same system as the ship's current location. Navigating will consume
	// the necessary fuel from the ship's manifest based on the distance to the target waypoint.
	// The returned response will detail the route information including the expected time of arrival.
	// Most ship actions are unavailable until the ship has arrived at it's destination.
	// To travel between systems, see the ship's Warp or Jump actions.
	//
	// POST /my/ships/{shipSymbol}/navigate
	NavigateShip(ctx context.Context, request OptNavigateShipReq, params NavigateShipParams) (*NavigateShipOK, error)
	// NegotiateContract invokes negotiateContract operation.
	//
	// Negotiate a new contract with the HQ.
	// In order to negotiate a new contract, an agent must not have ongoing or offered contracts over the
	// allowed maximum amount. Currently the maximum contracts an agent can have at a time is 1.
	// Once a contract is negotiated, it is added to the list of contracts offered to the agent, which
	// the agent can then accept.
	// The ship must be present at any waypoint with a faction present to negotiate a contract with that
	// faction.
	//
	// POST /my/ships/{shipSymbol}/negotiate/contract
	NegotiateContract(ctx context.Context, params NegotiateContractParams) (*NegotiateContractCreated, error)
	// OrbitShip invokes orbit-ship operation.
	//
	// Attempt to move your ship into orbit at its current location. The request will only succeed if
	// your ship is capable of moving into orbit at the time of the request.
	// Orbiting ships are able to do actions that require the ship to be above surface such as navigating
	// or extracting, but cannot access elements in their current waypoint, such as the market or a
	// shipyard.
	// The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.
	//
	// POST /my/ships/{shipSymbol}/orbit
	OrbitShip(ctx context.Context, params OrbitShipParams) (*OrbitShipOK, error)
	// PatchShipNav invokes patch-ship-nav operation.
	//
	// Update the nav configuration of a ship.
	// Currently only supports configuring the Flight Mode of the ship, which affects its speed and fuel
	// consumption.
	//
	// PATCH /my/ships/{shipSymbol}/nav
	PatchShipNav(ctx context.Context, request OptPatchShipNavReq, params PatchShipNavParams) (*PatchShipNavOK, error)
	// PurchaseCargo invokes purchase-cargo operation.
	//
	// Purchase cargo from a market.
	// The ship must be docked in a waypoint that has `Marketplace` trait, and the market must be selling
	// a good to be able to purchase it.
	// The maximum amount of units of a good that can be purchased in each transaction are denoted by the
	// `tradeVolume` value of the good, which can be viewed by using the Get Market action.
	// Purchased goods are added to the ship's cargo hold.
	//
	// POST /my/ships/{shipSymbol}/purchase
	PurchaseCargo(ctx context.Context, request OptPurchaseCargoReq, params PurchaseCargoParams) (*PurchaseCargoCreated, error)
	// PurchaseShip invokes purchase-ship operation.
	//
	// Purchase a ship from a Shipyard. In order to use this function, a ship under your agent's
	// ownership must be in a waypoint that has the `Shipyard` trait, and the Shipyard must sell the type
	// of the desired ship.
	// Shipyards typically offer ship types, which are predefined templates of ships that have dedicated
	// roles. A template comes with a preset of an engine, a reactor, and a frame. It may also include a
	// few modules and mounts.
	//
	// POST /my/ships
	PurchaseShip(ctx context.Context, request OptPurchaseShipReq) (*PurchaseShipCreated, error)
	// RefuelShip invokes refuel-ship operation.
	//
	// Refuel your ship by buying fuel from the local market.
	// Requires the ship to be docked in a waypoint that has the `Marketplace` trait, and the market must
	// be selling fuel in order to refuel.
	// Each fuel bought from the market replenishes 100 units in your ship's fuel.
	// Ships will always be refuel to their frame's maximum fuel capacity when using this action.
	//
	// POST /my/ships/{shipSymbol}/refuel
	RefuelShip(ctx context.Context, request OptRefuelShipReq, params RefuelShipParams) (*RefuelShipOK, error)
	// Register invokes register operation.
	//
	// Creates a new agent and ties it to an account.
	// The agent symbol must consist of a 3-14 character string, and will be used to represent your agent.
	//  This symbol will prefix the symbol of every ship you own. Agent symbols will be cast to all
	// uppercase characters.
	// This new agent will be tied to a starting faction of your choice, which determines your starting
	// location, and will be granted an authorization token, a contract with their starting faction, a
	// command ship that can fly across space with advanced capabilities, a small probe ship that can be
	// used for reconnaissance, and 150,000 credits.
	// > #### Keep your token safe and secure
	// >
	// > Save your token during the alpha phase. There is no way to regenerate this token without
	// starting a new agent. In the future you will be able to generate and manage your tokens from the
	// SpaceTraders website.
	// If you are new to SpaceTraders, It is recommended to register with the COSMIC faction, a faction
	// that is well connected to the rest of the universe. After registering, you should try our
	// interactive [quickstart guide](https://docs.spacetraders.io/quickstart/new-game) which will walk
	// you through basic API requests in just a few minutes.
	//
	// POST /register
	Register(ctx context.Context, request OptRegisterReq) (*RegisterCreated, error)
	// RemoveMount invokes remove-mount operation.
	//
	// Remove a mount from a ship.
	// The ship must be docked in a waypoint that has the `Shipyard` trait, and must have the desired
	// mount that it wish to remove installed.
	// A removal fee will be deduced from the agent by the Shipyard.
	//
	// POST /my/ships/{shipSymbol}/mounts/remove
	RemoveMount(ctx context.Context, request OptRemoveMountReq, params RemoveMountParams) (*RemoveMountCreated, error)
	// RepairShip invokes repair-ship operation.
	//
	// Repair a ship, restoring the ship to maximum condition. The ship must be docked at a waypoint that
	// has the `Shipyard` trait in order to use this function. To preview the cost of repairing the ship,
	// use the Get action.
	//
	// POST /my/ships/{shipSymbol}/repair
	RepairShip(ctx context.Context, params RepairShipParams) (*RepairShipOK, error)
	// ScrapShip invokes scrap-ship operation.
	//
	// Scrap a ship, removing it from the game and returning a portion of the ship's value to the agent.
	// The ship must be docked in a waypoint that has the `Shipyard` trait in order to use this function.
	// To preview the amount of value that will be returned, use the Get Ship action.
	//
	// POST /my/ships/{shipSymbol}/scrap
	ScrapShip(ctx context.Context, params ScrapShipParams) (*ScrapShipOK, error)
	// SellCargo invokes sell-cargo operation.
	//
	// Sell cargo in your ship to a market that trades this cargo. The ship must be docked in a waypoint
	// that has the `Marketplace` trait in order to use this function.
	//
	// POST /my/ships/{shipSymbol}/sell
	SellCargo(ctx context.Context, request OptSellCargoReq, params SellCargoParams) (*SellCargoCreated, error)
	// ShipRefine invokes ship-refine operation.
	//
	// Attempt to refine the raw materials on your ship. The request will only succeed if your ship is
	// capable of refining at the time of the request. In order to be able to refine, a ship must have
	// goods that can be refined and have installed a `Refinery` module that can refine it.
	// When refining, 30 basic goods will be converted into 10 processed goods.
	//
	// POST /my/ships/{shipSymbol}/refine
	ShipRefine(ctx context.Context, request OptShipRefineReq, params ShipRefineParams) (*ShipRefineCreated, error)
	// SiphonResources invokes siphon-resources operation.
	//
	// Siphon gases, such as hydrocarbon, from gas giants.
	// The ship must be in orbit to be able to siphon and must have siphon mounts and a gas processor
	// installed.
	//
	// POST /my/ships/{shipSymbol}/siphon
	SiphonResources(ctx context.Context, params SiphonResourcesParams) (*SiphonResourcesCreated, error)
	// SupplyConstruction invokes supply-construction operation.
	//
	// Supply a construction site with the specified good. Requires a waypoint with a property of
	// `isUnderConstruction` to be true.
	// The good must be in your ship's cargo. The good will be removed from your ship's cargo and added
	// to the construction site's materials.
	//
	// POST /systems/{systemSymbol}/waypoints/{waypointSymbol}/construction/supply
	SupplyConstruction(ctx context.Context, request OptSupplyConstructionReq, params SupplyConstructionParams) (*SupplyConstructionCreated, error)
	// TransferCargo invokes transfer-cargo operation.
	//
	// Transfer cargo between ships.
	// The receiving ship must be in the same waypoint as the transferring ship, and it must able to hold
	// the additional cargo after the transfer is complete. Both ships also must be in the same state,
	// either both are docked or both are orbiting.
	// The response body's cargo shows the cargo of the transferring ship after the transfer is complete.
	//
	// POST /my/ships/{shipSymbol}/transfer
	TransferCargo(ctx context.Context, request OptTransferCargoReq, params TransferCargoParams) (*TransferCargoOK, error)
	// WarpShip invokes warp-ship operation.
	//
	// Warp your ship to a target destination in another system. The ship must be in orbit to use this
	// function and must have the `Warp Drive` module installed. Warping will consume the necessary fuel
	// from the ship's manifest.
	// The returned response will detail the route information including the expected time of arrival.
	// Most ship actions are unavailable until the ship has arrived at its destination.
	//
	// POST /my/ships/{shipSymbol}/warp
	WarpShip(ctx context.Context, request OptWarpShipReq, params WarpShipParams) (*WarpShipOK, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AcceptContract invokes accept-contract operation.
//
// Accept a contract by ID.
// You can only accept contracts that were offered to you, were not accepted yet, and whose deadlines
// has not passed yet.
//
// POST /my/contracts/{contractId}/accept
func (c *Client) AcceptContract(ctx context.Context, params AcceptContractParams) (*AcceptContractOK, error) {
	res, err := c.sendAcceptContract(ctx, params)
	return res, err
}

func (c *Client) sendAcceptContract(ctx context.Context, params AcceptContractParams) (res *AcceptContractOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("accept-contract"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/contracts/{contractId}/accept"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AcceptContract",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/contracts/"
	{
		// Encode "contractId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contractId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContractId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/accept"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "AcceptContract", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAcceptContractResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateChart invokes create-chart operation.
//
// Command a ship to chart the waypoint at its current location.
// Most waypoints in the universe are uncharted by default. These waypoints have their traits hidden
// until they have been charted by a ship.
// Charting a waypoint will record your agent as the one who created the chart, and all other agents
// would also be able to see the waypoint's traits.
//
// POST /my/ships/{shipSymbol}/chart
func (c *Client) CreateChart(ctx context.Context, params CreateChartParams) (*CreateChartCreated, error) {
	res, err := c.sendCreateChart(ctx, params)
	return res, err
}

func (c *Client) sendCreateChart(ctx context.Context, params CreateChartParams) (res *CreateChartCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create-chart"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/chart"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateChart",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/chart"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "CreateChart", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateChartResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateShipShipScan invokes create-ship-ship-scan operation.
//
// Scan for nearby ships, retrieving information for all ships in range.
// Requires a ship to have the `Sensor Array` mount installed to use.
// The ship will enter a cooldown after using this function, during which it cannot execute certain
// actions.
//
// POST /my/ships/{shipSymbol}/scan/ships
func (c *Client) CreateShipShipScan(ctx context.Context, params CreateShipShipScanParams) (*CreateShipShipScanCreated, error) {
	res, err := c.sendCreateShipShipScan(ctx, params)
	return res, err
}

func (c *Client) sendCreateShipShipScan(ctx context.Context, params CreateShipShipScanParams) (res *CreateShipShipScanCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create-ship-ship-scan"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/scan/ships"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateShipShipScan",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/scan/ships"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "CreateShipShipScan", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateShipShipScanResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateShipSystemScan invokes create-ship-system-scan operation.
//
// Scan for nearby systems, retrieving information on the systems' distance from the ship and their
// waypoints. Requires a ship to have the `Sensor Array` mount installed to use.
// The ship will enter a cooldown after using this function, during which it cannot execute certain
// actions.
//
// POST /my/ships/{shipSymbol}/scan/systems
func (c *Client) CreateShipSystemScan(ctx context.Context, params CreateShipSystemScanParams) (*CreateShipSystemScanCreated, error) {
	res, err := c.sendCreateShipSystemScan(ctx, params)
	return res, err
}

func (c *Client) sendCreateShipSystemScan(ctx context.Context, params CreateShipSystemScanParams) (res *CreateShipSystemScanCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create-ship-system-scan"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/scan/systems"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateShipSystemScan",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/scan/systems"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "CreateShipSystemScan", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateShipSystemScanResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateShipWaypointScan invokes create-ship-waypoint-scan operation.
//
// Scan for nearby waypoints, retrieving detailed information on each waypoint in range. Scanning
// uncharted waypoints will allow you to ignore their uncharted state and will list the waypoints'
// traits.
// Requires a ship to have the `Sensor Array` mount installed to use.
// The ship will enter a cooldown after using this function, during which it cannot execute certain
// actions.
//
// POST /my/ships/{shipSymbol}/scan/waypoints
func (c *Client) CreateShipWaypointScan(ctx context.Context, params CreateShipWaypointScanParams) (*CreateShipWaypointScanCreated, error) {
	res, err := c.sendCreateShipWaypointScan(ctx, params)
	return res, err
}

func (c *Client) sendCreateShipWaypointScan(ctx context.Context, params CreateShipWaypointScanParams) (res *CreateShipWaypointScanCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create-ship-waypoint-scan"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/scan/waypoints"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateShipWaypointScan",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/scan/waypoints"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "CreateShipWaypointScan", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateShipWaypointScanResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSurvey invokes create-survey operation.
//
// Create surveys on a waypoint that can be extracted such as asteroid fields. A survey focuses on
// specific types of deposits from the extracted location. When ships extract using this survey, they
// are guaranteed to procure a high amount of one of the goods in the survey.
// In order to use a survey, send the entire survey details in the body of the extract request.
// Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a
// higher chance of extracting that resource.
// Your ship will enter a cooldown after surveying in which it is unable to perform certain actions.
// Surveys will eventually expire after a period of time or will be exhausted after being extracted
// several times based on the survey's size. Multiple ships can use the same survey for extraction.
// A ship must have the `Surveyor` mount installed in order to use this function.
//
// POST /my/ships/{shipSymbol}/survey
func (c *Client) CreateSurvey(ctx context.Context, params CreateSurveyParams) (*CreateSurveyCreated, error) {
	res, err := c.sendCreateSurvey(ctx, params)
	return res, err
}

func (c *Client) sendCreateSurvey(ctx context.Context, params CreateSurveyParams) (res *CreateSurveyCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create-survey"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/survey"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "CreateSurvey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/survey"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "CreateSurvey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateSurveyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeliverContract invokes deliver-contract operation.
//
// Deliver cargo to a contract.
// In order to use this API, a ship must be at the delivery location (denoted in the delivery terms
// as `destinationSymbol` of a contract) and must have a number of units of a good required by this
// contract in its cargo.
// Cargo that was delivered will be removed from the ship's cargo.
//
// POST /my/contracts/{contractId}/deliver
func (c *Client) DeliverContract(ctx context.Context, request OptDeliverContractReq, params DeliverContractParams) (*DeliverContractOK, error) {
	res, err := c.sendDeliverContract(ctx, request, params)
	return res, err
}

func (c *Client) sendDeliverContract(ctx context.Context, request OptDeliverContractReq, params DeliverContractParams) (res *DeliverContractOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deliver-contract"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/contracts/{contractId}/deliver"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DeliverContract",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/contracts/"
	{
		// Encode "contractId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contractId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContractId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/deliver"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeliverContractRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "DeliverContract", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeliverContractResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DockShip invokes dock-ship operation.
//
// Attempt to dock your ship at its current location. Docking will only succeed if your ship is
// capable of docking at the time of the request.
// Docked ships can access elements in their current location, such as the market or a shipyard, but
// cannot do actions that require the ship to be above surface such as navigating or extracting.
// The endpoint is idempotent - successive calls will succeed even if the ship is already docked.
//
// POST /my/ships/{shipSymbol}/dock
func (c *Client) DockShip(ctx context.Context, params DockShipParams) (*DockShipOK, error) {
	res, err := c.sendDockShip(ctx, params)
	return res, err
}

func (c *Client) sendDockShip(ctx context.Context, params DockShipParams) (res *DockShipOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("dock-ship"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/dock"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "DockShip",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/dock"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "DockShip", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDockShipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExtractResources invokes extract-resources operation.
//
// Extract resources from a waypoint that can be extracted, such as asteroid fields, into your ship.
// Send an optional survey as the payload to target specific yields.
// The ship must be in orbit to be able to extract and must have mining equipments installed that can
// extract goods, such as the `Gas Siphon` mount for gas-based goods or `Mining Laser` mount for
// ore-based goods.
// The survey property is now deprecated. See the `extract/survey` endpoint for more details.
//
// POST /my/ships/{shipSymbol}/extract
func (c *Client) ExtractResources(ctx context.Context, request OptExtractResourcesReq, params ExtractResourcesParams) (*ExtractResourcesCreated, error) {
	res, err := c.sendExtractResources(ctx, request, params)
	return res, err
}

func (c *Client) sendExtractResources(ctx context.Context, request OptExtractResourcesReq, params ExtractResourcesParams) (res *ExtractResourcesCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("extract-resources"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/extract"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ExtractResources",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/extract"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExtractResourcesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "ExtractResources", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeExtractResourcesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExtractResourcesWithSurvey invokes extract-resources-with-survey operation.
//
// Use a survey when extracting resources from a waypoint. This endpoint requires a survey as the
// payload, which allows your ship to extract specific yields.
// Send the full survey object as the payload which will be validated according to the signature. If
// the signature is invalid, or any properties of the survey are changed, the request will fail.
//
// POST /my/ships/{shipSymbol}/extract/survey
func (c *Client) ExtractResourcesWithSurvey(ctx context.Context, request OptSurvey, params ExtractResourcesWithSurveyParams) (*ExtractResourcesWithSurveyCreated, error) {
	res, err := c.sendExtractResourcesWithSurvey(ctx, request, params)
	return res, err
}

func (c *Client) sendExtractResourcesWithSurvey(ctx context.Context, request OptSurvey, params ExtractResourcesWithSurveyParams) (res *ExtractResourcesWithSurveyCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("extract-resources-with-survey"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/extract/survey"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ExtractResourcesWithSurvey",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/extract/survey"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExtractResourcesWithSurveyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "ExtractResourcesWithSurvey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeExtractResourcesWithSurveyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FulfillContract invokes fulfill-contract operation.
//
// Fulfill a contract. Can only be used on contracts that have all of their delivery terms fulfilled.
//
// POST /my/contracts/{contractId}/fulfill
func (c *Client) FulfillContract(ctx context.Context, params FulfillContractParams) (*FulfillContractOK, error) {
	res, err := c.sendFulfillContract(ctx, params)
	return res, err
}

func (c *Client) sendFulfillContract(ctx context.Context, params FulfillContractParams) (res *FulfillContractOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("fulfill-contract"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/contracts/{contractId}/fulfill"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "FulfillContract",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/contracts/"
	{
		// Encode "contractId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contractId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContractId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/fulfill"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "FulfillContract", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFulfillContractResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAgent invokes get-agent operation.
//
// Fetch agent details.
//
// GET /agents/{agentSymbol}
func (c *Client) GetAgent(ctx context.Context, params GetAgentParams) (*GetAgentOK, error) {
	res, err := c.sendGetAgent(ctx, params)
	return res, err
}

func (c *Client) sendGetAgent(ctx context.Context, params GetAgentParams) (res *GetAgentOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-agent"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/agents/{agentSymbol}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAgent",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/agents/"
	{
		// Encode "agentSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "agentSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AgentSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetAgent", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{},
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAgentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAgents invokes get-agents operation.
//
// Fetch agents details.
//
// GET /agents
func (c *Client) GetAgents(ctx context.Context, params GetAgentsParams) (*GetAgentsOK, error) {
	res, err := c.sendGetAgents(ctx, params)
	return res, err
}

func (c *Client) sendGetAgents(ctx context.Context, params GetAgentsParams) (res *GetAgentsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-agents"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/agents"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetAgents",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/agents"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetAgents", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{},
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAgentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetConstruction invokes get-construction operation.
//
// Get construction details for a waypoint. Requires a waypoint with a property of
// `isUnderConstruction` to be true.
//
// GET /systems/{systemSymbol}/waypoints/{waypointSymbol}/construction
func (c *Client) GetConstruction(ctx context.Context, params GetConstructionParams) (*GetConstructionOK, error) {
	res, err := c.sendGetConstruction(ctx, params)
	return res, err
}

func (c *Client) sendGetConstruction(ctx context.Context, params GetConstructionParams) (res *GetConstructionOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-construction"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/systems/{systemSymbol}/waypoints/{waypointSymbol}/construction"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetConstruction",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/systems/"
	{
		// Encode "systemSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "systemSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SystemSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/waypoints/"
	{
		// Encode "waypointSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "waypointSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WaypointSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/construction"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetConstruction", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{},
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetConstructionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetContract invokes get-contract operation.
//
// Get the details of a contract by ID.
//
// GET /my/contracts/{contractId}
func (c *Client) GetContract(ctx context.Context, params GetContractParams) (*GetContractOK, error) {
	res, err := c.sendGetContract(ctx, params)
	return res, err
}

func (c *Client) sendGetContract(ctx context.Context, params GetContractParams) (res *GetContractOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-contract"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/contracts/{contractId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetContract",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/my/contracts/"
	{
		// Encode "contractId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "contractId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContractId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetContract", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetContractResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetContracts invokes get-contracts operation.
//
// Return a paginated list of all your contracts.
//
// GET /my/contracts
func (c *Client) GetContracts(ctx context.Context, params GetContractsParams) (*GetContractsOK, error) {
	res, err := c.sendGetContracts(ctx, params)
	return res, err
}

func (c *Client) sendGetContracts(ctx context.Context, params GetContractsParams) (res *GetContractsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-contracts"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/contracts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetContracts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/contracts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetContracts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetContractsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFaction invokes get-faction operation.
//
// View the details of a faction.
//
// GET /factions/{factionSymbol}
func (c *Client) GetFaction(ctx context.Context, params GetFactionParams) (*GetFactionOK, error) {
	res, err := c.sendGetFaction(ctx, params)
	return res, err
}

func (c *Client) sendGetFaction(ctx context.Context, params GetFactionParams) (res *GetFactionOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-faction"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/factions/{factionSymbol}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetFaction",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/factions/"
	{
		// Encode "factionSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "factionSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.FactionSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetFaction", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetFactionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFactions invokes get-factions operation.
//
// Return a paginated list of all the factions in the game.
//
// GET /factions
func (c *Client) GetFactions(ctx context.Context, params GetFactionsParams) (*GetFactionsOK, error) {
	res, err := c.sendGetFactions(ctx, params)
	return res, err
}

func (c *Client) sendGetFactions(ctx context.Context, params GetFactionsParams) (res *GetFactionsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-factions"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/factions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetFactions",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/factions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetFactions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{},
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetFactionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetJumpGate invokes get-jump-gate operation.
//
// Get jump gate details for a waypoint. Requires a waypoint of type `JUMP_GATE` to use.
// Waypoints connected to this jump gate can be.
//
// GET /systems/{systemSymbol}/waypoints/{waypointSymbol}/jump-gate
func (c *Client) GetJumpGate(ctx context.Context, params GetJumpGateParams) (*GetJumpGateOK, error) {
	res, err := c.sendGetJumpGate(ctx, params)
	return res, err
}

func (c *Client) sendGetJumpGate(ctx context.Context, params GetJumpGateParams) (res *GetJumpGateOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-jump-gate"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/systems/{systemSymbol}/waypoints/{waypointSymbol}/jump-gate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetJumpGate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/systems/"
	{
		// Encode "systemSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "systemSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SystemSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/waypoints/"
	{
		// Encode "waypointSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "waypointSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WaypointSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/jump-gate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetJumpGate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{},
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetJumpGateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMarket invokes get-market operation.
//
// Retrieve imports, exports and exchange data from a marketplace. Requires a waypoint that has the
// `Marketplace` trait to use.
// Send a ship to the waypoint to access trade good prices and recent transactions. Refer to the
// [Market Overview page](https://docs.spacetraders.io/game-concepts/markets) to gain better a
// understanding of the market in the game.
//
// GET /systems/{systemSymbol}/waypoints/{waypointSymbol}/market
func (c *Client) GetMarket(ctx context.Context, params GetMarketParams) (*GetMarketOK, error) {
	res, err := c.sendGetMarket(ctx, params)
	return res, err
}

func (c *Client) sendGetMarket(ctx context.Context, params GetMarketParams) (res *GetMarketOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-market"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/systems/{systemSymbol}/waypoints/{waypointSymbol}/market"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMarket",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/systems/"
	{
		// Encode "systemSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "systemSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SystemSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/waypoints/"
	{
		// Encode "waypointSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "waypointSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WaypointSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/market"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetMarket", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{},
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMarketResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMounts invokes get-mounts operation.
//
// Get the mounts installed on a ship.
//
// GET /my/ships/{shipSymbol}/mounts
func (c *Client) GetMounts(ctx context.Context, params GetMountsParams) (*GetMountsOK, error) {
	res, err := c.sendGetMounts(ctx, params)
	return res, err
}

func (c *Client) sendGetMounts(ctx context.Context, params GetMountsParams) (res *GetMountsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-mounts"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/mounts"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMounts",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/mounts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetMounts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMountsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyAgent invokes get-my-agent operation.
//
// Fetch your agent's details.
//
// GET /my/agent
func (c *Client) GetMyAgent(ctx context.Context) (*GetMyAgentOK, error) {
	res, err := c.sendGetMyAgent(ctx)
	return res, err
}

func (c *Client) sendGetMyAgent(ctx context.Context) (res *GetMyAgentOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-my-agent"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/agent"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMyAgent",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/agent"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetMyAgent", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMyAgentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyShip invokes get-my-ship operation.
//
// Retrieve the details of a ship under your agent's ownership.
//
// GET /my/ships/{shipSymbol}
func (c *Client) GetMyShip(ctx context.Context, params GetMyShipParams) (*GetMyShipOK, error) {
	res, err := c.sendGetMyShip(ctx, params)
	return res, err
}

func (c *Client) sendGetMyShip(ctx context.Context, params GetMyShipParams) (res *GetMyShipOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-my-ship"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMyShip",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetMyShip", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMyShipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyShipCargo invokes get-my-ship-cargo operation.
//
// Retrieve the cargo of a ship under your agent's ownership.
//
// GET /my/ships/{shipSymbol}/cargo
func (c *Client) GetMyShipCargo(ctx context.Context, params GetMyShipCargoParams) (*GetMyShipCargoOK, error) {
	res, err := c.sendGetMyShipCargo(ctx, params)
	return res, err
}

func (c *Client) sendGetMyShipCargo(ctx context.Context, params GetMyShipCargoParams) (res *GetMyShipCargoOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-my-ship-cargo"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/cargo"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMyShipCargo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/cargo"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetMyShipCargo", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMyShipCargoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyShips invokes get-my-ships operation.
//
// Return a paginated list of all of ships under your agent's ownership.
//
// GET /my/ships
func (c *Client) GetMyShips(ctx context.Context, params GetMyShipsParams) (*GetMyShipsOK, error) {
	res, err := c.sendGetMyShips(ctx, params)
	return res, err
}

func (c *Client) sendGetMyShips(ctx context.Context, params GetMyShipsParams) (res *GetMyShipsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-my-ships"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/ships"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetMyShips",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/ships"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetMyShips", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMyShipsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRepairShip invokes get-repair-ship operation.
//
// Get the cost of repairing a ship.
//
// GET /my/ships/{shipSymbol}/repair
func (c *Client) GetRepairShip(ctx context.Context, params GetRepairShipParams) (*GetRepairShipOK, error) {
	res, err := c.sendGetRepairShip(ctx, params)
	return res, err
}

func (c *Client) sendGetRepairShip(ctx context.Context, params GetRepairShipParams) (res *GetRepairShipOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-repair-ship"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/repair"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetRepairShip",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repair"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetRepairShip", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetRepairShipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetScrapShip invokes get-scrap-ship operation.
//
// Get the amount of value that will be returned when scrapping a ship.
//
// GET /my/ships/{shipSymbol}/scrap
func (c *Client) GetScrapShip(ctx context.Context, params GetScrapShipParams) (*GetScrapShipOK, error) {
	res, err := c.sendGetScrapShip(ctx, params)
	return res, err
}

func (c *Client) sendGetScrapShip(ctx context.Context, params GetScrapShipParams) (res *GetScrapShipOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-scrap-ship"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/scrap"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetScrapShip",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/scrap"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetScrapShip", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetScrapShipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetShipCooldown invokes get-ship-cooldown operation.
//
// Retrieve the details of your ship's reactor cooldown. Some actions such as activating your jump
// drive, scanning, or extracting resources taxes your reactor and results in a cooldown.
// Your ship cannot perform additional actions until your cooldown has expired. The duration of your
// cooldown is relative to the power consumption of the related modules or mounts for the action
// taken.
// Response returns a 204 status code (no-content) when the ship has no cooldown.
//
// GET /my/ships/{shipSymbol}/cooldown
func (c *Client) GetShipCooldown(ctx context.Context, params GetShipCooldownParams) (GetShipCooldownRes, error) {
	res, err := c.sendGetShipCooldown(ctx, params)
	return res, err
}

func (c *Client) sendGetShipCooldown(ctx context.Context, params GetShipCooldownParams) (res GetShipCooldownRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-ship-cooldown"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/cooldown"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetShipCooldown",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/cooldown"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetShipCooldown", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetShipCooldownResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetShipNav invokes get-ship-nav operation.
//
// Get the current nav status of a ship.
//
// GET /my/ships/{shipSymbol}/nav
func (c *Client) GetShipNav(ctx context.Context, params GetShipNavParams) (*GetShipNavOK, error) {
	res, err := c.sendGetShipNav(ctx, params)
	return res, err
}

func (c *Client) sendGetShipNav(ctx context.Context, params GetShipNavParams) (res *GetShipNavOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-ship-nav"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/nav"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetShipNav",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/nav"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetShipNav", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetShipNavResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetShipyard invokes get-shipyard operation.
//
// Get the shipyard for a waypoint. Requires a waypoint that has the `Shipyard` trait to use. Send a
// ship to the waypoint to access data on ships that are currently available for purchase and recent
// transactions.
//
// GET /systems/{systemSymbol}/waypoints/{waypointSymbol}/shipyard
func (c *Client) GetShipyard(ctx context.Context, params GetShipyardParams) (*GetShipyardOK, error) {
	res, err := c.sendGetShipyard(ctx, params)
	return res, err
}

func (c *Client) sendGetShipyard(ctx context.Context, params GetShipyardParams) (res *GetShipyardOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-shipyard"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/systems/{systemSymbol}/waypoints/{waypointSymbol}/shipyard"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetShipyard",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/systems/"
	{
		// Encode "systemSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "systemSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SystemSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/waypoints/"
	{
		// Encode "waypointSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "waypointSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WaypointSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/shipyard"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetShipyard", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{},
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetShipyardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStatus invokes get-status operation.
//
// Return the status of the game server.
// This also includes a few global elements, such as announcements, server reset dates and
// leaderboards.
//
// GET /
func (c *Client) GetStatus(ctx context.Context) (*GetStatusOK, error) {
	res, err := c.sendGetStatus(ctx)
	return res, err
}

func (c *Client) sendGetStatus(ctx context.Context) (res *GetStatusOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-status"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetStatus",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetStatus", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{},
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSystem invokes get-system operation.
//
// Get the details of a system.
//
// GET /systems/{systemSymbol}
func (c *Client) GetSystem(ctx context.Context, params GetSystemParams) (*GetSystemOK, error) {
	res, err := c.sendGetSystem(ctx, params)
	return res, err
}

func (c *Client) sendGetSystem(ctx context.Context, params GetSystemParams) (res *GetSystemOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-system"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/systems/{systemSymbol}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSystem",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/systems/"
	{
		// Encode "systemSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "systemSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SystemSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetSystem", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{},
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSystemResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSystemWaypoints invokes get-system-waypoints operation.
//
// Return a paginated list of all of the waypoints for a given system.
// If a waypoint is uncharted, it will return the `Uncharted` trait instead of its actual traits.
//
// GET /systems/{systemSymbol}/waypoints
func (c *Client) GetSystemWaypoints(ctx context.Context, params GetSystemWaypointsParams) (*GetSystemWaypointsOK, error) {
	res, err := c.sendGetSystemWaypoints(ctx, params)
	return res, err
}

func (c *Client) sendGetSystemWaypoints(ctx context.Context, params GetSystemWaypointsParams) (res *GetSystemWaypointsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-system-waypoints"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/systems/{systemSymbol}/waypoints"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSystemWaypoints",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/systems/"
	{
		// Encode "systemSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "systemSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SystemSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/waypoints"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetSystemWaypoints", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{},
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSystemWaypointsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSystems invokes get-systems operation.
//
// Return a paginated list of all systems.
//
// GET /systems
func (c *Client) GetSystems(ctx context.Context, params GetSystemsParams) (*GetSystemsOK, error) {
	res, err := c.sendGetSystems(ctx, params)
	return res, err
}

func (c *Client) sendGetSystems(ctx context.Context, params GetSystemsParams) (res *GetSystemsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-systems"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/systems"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetSystems",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/systems"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetSystems", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{},
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSystemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWaypoint invokes get-waypoint operation.
//
// View the details of a waypoint.
// If the waypoint is uncharted, it will return the 'Uncharted' trait instead of its actual traits.
//
// GET /systems/{systemSymbol}/waypoints/{waypointSymbol}
func (c *Client) GetWaypoint(ctx context.Context, params GetWaypointParams) (*GetWaypointOK, error) {
	res, err := c.sendGetWaypoint(ctx, params)
	return res, err
}

func (c *Client) sendGetWaypoint(ctx context.Context, params GetWaypointParams) (res *GetWaypointOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get-waypoint"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/systems/{systemSymbol}/waypoints/{waypointSymbol}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "GetWaypoint",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/systems/"
	{
		// Encode "systemSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "systemSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SystemSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/waypoints/"
	{
		// Encode "waypointSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "waypointSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WaypointSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "GetWaypoint", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{},
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWaypointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstallMount invokes install-mount operation.
//
// Install a mount on a ship.
// In order to install a mount, the ship must be docked and located in a waypoint that has a
// `Shipyard` trait. The ship also must have the mount to install in its cargo hold.
// An installation fee will be deduced by the Shipyard for installing the mount on the ship.
//
// POST /my/ships/{shipSymbol}/mounts/install
func (c *Client) InstallMount(ctx context.Context, request OptInstallMountReq, params InstallMountParams) (*InstallMountCreated, error) {
	res, err := c.sendInstallMount(ctx, request, params)
	return res, err
}

func (c *Client) sendInstallMount(ctx context.Context, request OptInstallMountReq, params InstallMountParams) (res *InstallMountCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("install-mount"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/mounts/install"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstallMount",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/mounts/install"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstallMountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "InstallMount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstallMountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Jettison invokes jettison operation.
//
// Jettison cargo from your ship's cargo hold.
//
// POST /my/ships/{shipSymbol}/jettison
func (c *Client) Jettison(ctx context.Context, request OptJettisonReq, params JettisonParams) (*JettisonOK, error) {
	res, err := c.sendJettison(ctx, request, params)
	return res, err
}

func (c *Client) sendJettison(ctx context.Context, request OptJettisonReq, params JettisonParams) (res *JettisonOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("jettison"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/jettison"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "Jettison",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/jettison"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeJettisonRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "Jettison", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeJettisonResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// JumpShip invokes jump-ship operation.
//
// Jump your ship instantly to a target connected waypoint. The ship must be in orbit to execute a
// jump.
// A unit of antimatter is purchased and consumed from the market when jumping. The price of
// antimatter is determined by the market and is subject to change. A ship can only jump to connected
// waypoints.
//
// POST /my/ships/{shipSymbol}/jump
func (c *Client) JumpShip(ctx context.Context, request OptJumpShipReq, params JumpShipParams) (*JumpShipOK, error) {
	res, err := c.sendJumpShip(ctx, request, params)
	return res, err
}

func (c *Client) sendJumpShip(ctx context.Context, request OptJumpShipReq, params JumpShipParams) (res *JumpShipOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("jump-ship"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/jump"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "JumpShip",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/jump"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeJumpShipRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "JumpShip", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeJumpShipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NavigateShip invokes navigate-ship operation.
//
// Navigate to a target destination. The ship must be in orbit to use this function. The destination
// waypoint must be within the same system as the ship's current location. Navigating will consume
// the necessary fuel from the ship's manifest based on the distance to the target waypoint.
// The returned response will detail the route information including the expected time of arrival.
// Most ship actions are unavailable until the ship has arrived at it's destination.
// To travel between systems, see the ship's Warp or Jump actions.
//
// POST /my/ships/{shipSymbol}/navigate
func (c *Client) NavigateShip(ctx context.Context, request OptNavigateShipReq, params NavigateShipParams) (*NavigateShipOK, error) {
	res, err := c.sendNavigateShip(ctx, request, params)
	return res, err
}

func (c *Client) sendNavigateShip(ctx context.Context, request OptNavigateShipReq, params NavigateShipParams) (res *NavigateShipOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("navigate-ship"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/navigate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "NavigateShip",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/navigate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNavigateShipRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "NavigateShip", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeNavigateShipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NegotiateContract invokes negotiateContract operation.
//
// Negotiate a new contract with the HQ.
// In order to negotiate a new contract, an agent must not have ongoing or offered contracts over the
// allowed maximum amount. Currently the maximum contracts an agent can have at a time is 1.
// Once a contract is negotiated, it is added to the list of contracts offered to the agent, which
// the agent can then accept.
// The ship must be present at any waypoint with a faction present to negotiate a contract with that
// faction.
//
// POST /my/ships/{shipSymbol}/negotiate/contract
func (c *Client) NegotiateContract(ctx context.Context, params NegotiateContractParams) (*NegotiateContractCreated, error) {
	res, err := c.sendNegotiateContract(ctx, params)
	return res, err
}

func (c *Client) sendNegotiateContract(ctx context.Context, params NegotiateContractParams) (res *NegotiateContractCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("negotiateContract"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/negotiate/contract"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "NegotiateContract",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/negotiate/contract"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "NegotiateContract", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeNegotiateContractResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrbitShip invokes orbit-ship operation.
//
// Attempt to move your ship into orbit at its current location. The request will only succeed if
// your ship is capable of moving into orbit at the time of the request.
// Orbiting ships are able to do actions that require the ship to be above surface such as navigating
// or extracting, but cannot access elements in their current waypoint, such as the market or a
// shipyard.
// The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.
//
// POST /my/ships/{shipSymbol}/orbit
func (c *Client) OrbitShip(ctx context.Context, params OrbitShipParams) (*OrbitShipOK, error) {
	res, err := c.sendOrbitShip(ctx, params)
	return res, err
}

func (c *Client) sendOrbitShip(ctx context.Context, params OrbitShipParams) (res *OrbitShipOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("orbit-ship"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/orbit"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "OrbitShip",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/orbit"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "OrbitShip", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOrbitShipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PatchShipNav invokes patch-ship-nav operation.
//
// Update the nav configuration of a ship.
// Currently only supports configuring the Flight Mode of the ship, which affects its speed and fuel
// consumption.
//
// PATCH /my/ships/{shipSymbol}/nav
func (c *Client) PatchShipNav(ctx context.Context, request OptPatchShipNavReq, params PatchShipNavParams) (*PatchShipNavOK, error) {
	res, err := c.sendPatchShipNav(ctx, request, params)
	return res, err
}

func (c *Client) sendPatchShipNav(ctx context.Context, request OptPatchShipNavReq, params PatchShipNavParams) (res *PatchShipNavOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("patch-ship-nav"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/nav"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PatchShipNav",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/nav"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePatchShipNavRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "PatchShipNav", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePatchShipNavResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PurchaseCargo invokes purchase-cargo operation.
//
// Purchase cargo from a market.
// The ship must be docked in a waypoint that has `Marketplace` trait, and the market must be selling
// a good to be able to purchase it.
// The maximum amount of units of a good that can be purchased in each transaction are denoted by the
// `tradeVolume` value of the good, which can be viewed by using the Get Market action.
// Purchased goods are added to the ship's cargo hold.
//
// POST /my/ships/{shipSymbol}/purchase
func (c *Client) PurchaseCargo(ctx context.Context, request OptPurchaseCargoReq, params PurchaseCargoParams) (*PurchaseCargoCreated, error) {
	res, err := c.sendPurchaseCargo(ctx, request, params)
	return res, err
}

func (c *Client) sendPurchaseCargo(ctx context.Context, request OptPurchaseCargoReq, params PurchaseCargoParams) (res *PurchaseCargoCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("purchase-cargo"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/purchase"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PurchaseCargo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/purchase"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePurchaseCargoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "PurchaseCargo", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePurchaseCargoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PurchaseShip invokes purchase-ship operation.
//
// Purchase a ship from a Shipyard. In order to use this function, a ship under your agent's
// ownership must be in a waypoint that has the `Shipyard` trait, and the Shipyard must sell the type
// of the desired ship.
// Shipyards typically offer ship types, which are predefined templates of ships that have dedicated
// roles. A template comes with a preset of an engine, a reactor, and a frame. It may also include a
// few modules and mounts.
//
// POST /my/ships
func (c *Client) PurchaseShip(ctx context.Context, request OptPurchaseShipReq) (*PurchaseShipCreated, error) {
	res, err := c.sendPurchaseShip(ctx, request)
	return res, err
}

func (c *Client) sendPurchaseShip(ctx context.Context, request OptPurchaseShipReq) (res *PurchaseShipCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("purchase-ship"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PurchaseShip",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/my/ships"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePurchaseShipRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "PurchaseShip", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePurchaseShipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RefuelShip invokes refuel-ship operation.
//
// Refuel your ship by buying fuel from the local market.
// Requires the ship to be docked in a waypoint that has the `Marketplace` trait, and the market must
// be selling fuel in order to refuel.
// Each fuel bought from the market replenishes 100 units in your ship's fuel.
// Ships will always be refuel to their frame's maximum fuel capacity when using this action.
//
// POST /my/ships/{shipSymbol}/refuel
func (c *Client) RefuelShip(ctx context.Context, request OptRefuelShipReq, params RefuelShipParams) (*RefuelShipOK, error) {
	res, err := c.sendRefuelShip(ctx, request, params)
	return res, err
}

func (c *Client) sendRefuelShip(ctx context.Context, request OptRefuelShipReq, params RefuelShipParams) (res *RefuelShipOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("refuel-ship"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/refuel"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RefuelShip",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/refuel"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRefuelShipRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "RefuelShip", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRefuelShipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Register invokes register operation.
//
// Creates a new agent and ties it to an account.
// The agent symbol must consist of a 3-14 character string, and will be used to represent your agent.
//
//	This symbol will prefix the symbol of every ship you own. Agent symbols will be cast to all
//
// uppercase characters.
// This new agent will be tied to a starting faction of your choice, which determines your starting
// location, and will be granted an authorization token, a contract with their starting faction, a
// command ship that can fly across space with advanced capabilities, a small probe ship that can be
// used for reconnaissance, and 150,000 credits.
// > #### Keep your token safe and secure
// >
// > Save your token during the alpha phase. There is no way to regenerate this token without
// starting a new agent. In the future you will be able to generate and manage your tokens from the
// SpaceTraders website.
// If you are new to SpaceTraders, It is recommended to register with the COSMIC faction, a faction
// that is well connected to the rest of the universe. After registering, you should try our
// interactive [quickstart guide](https://docs.spacetraders.io/quickstart/new-game) which will walk
// you through basic API requests in just a few minutes.
//
// POST /register
func (c *Client) Register(ctx context.Context, request OptRegisterReq) (*RegisterCreated, error) {
	res, err := c.sendRegister(ctx, request)
	return res, err
}

func (c *Client) sendRegister(ctx context.Context, request OptRegisterReq) (res *RegisterCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("register"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/register"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "Register",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/register"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRegisterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRegisterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveMount invokes remove-mount operation.
//
// Remove a mount from a ship.
// The ship must be docked in a waypoint that has the `Shipyard` trait, and must have the desired
// mount that it wish to remove installed.
// A removal fee will be deduced from the agent by the Shipyard.
//
// POST /my/ships/{shipSymbol}/mounts/remove
func (c *Client) RemoveMount(ctx context.Context, request OptRemoveMountReq, params RemoveMountParams) (*RemoveMountCreated, error) {
	res, err := c.sendRemoveMount(ctx, request, params)
	return res, err
}

func (c *Client) sendRemoveMount(ctx context.Context, request OptRemoveMountReq, params RemoveMountParams) (res *RemoveMountCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("remove-mount"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/mounts/remove"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RemoveMount",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/mounts/remove"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRemoveMountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "RemoveMount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveMountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RepairShip invokes repair-ship operation.
//
// Repair a ship, restoring the ship to maximum condition. The ship must be docked at a waypoint that
// has the `Shipyard` trait in order to use this function. To preview the cost of repairing the ship,
// use the Get action.
//
// POST /my/ships/{shipSymbol}/repair
func (c *Client) RepairShip(ctx context.Context, params RepairShipParams) (*RepairShipOK, error) {
	res, err := c.sendRepairShip(ctx, params)
	return res, err
}

func (c *Client) sendRepairShip(ctx context.Context, params RepairShipParams) (res *RepairShipOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("repair-ship"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/repair"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "RepairShip",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/repair"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "RepairShip", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRepairShipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ScrapShip invokes scrap-ship operation.
//
// Scrap a ship, removing it from the game and returning a portion of the ship's value to the agent.
// The ship must be docked in a waypoint that has the `Shipyard` trait in order to use this function.
// To preview the amount of value that will be returned, use the Get Ship action.
//
// POST /my/ships/{shipSymbol}/scrap
func (c *Client) ScrapShip(ctx context.Context, params ScrapShipParams) (*ScrapShipOK, error) {
	res, err := c.sendScrapShip(ctx, params)
	return res, err
}

func (c *Client) sendScrapShip(ctx context.Context, params ScrapShipParams) (res *ScrapShipOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("scrap-ship"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/scrap"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ScrapShip",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/scrap"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "ScrapShip", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeScrapShipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SellCargo invokes sell-cargo operation.
//
// Sell cargo in your ship to a market that trades this cargo. The ship must be docked in a waypoint
// that has the `Marketplace` trait in order to use this function.
//
// POST /my/ships/{shipSymbol}/sell
func (c *Client) SellCargo(ctx context.Context, request OptSellCargoReq, params SellCargoParams) (*SellCargoCreated, error) {
	res, err := c.sendSellCargo(ctx, request, params)
	return res, err
}

func (c *Client) sendSellCargo(ctx context.Context, request OptSellCargoReq, params SellCargoParams) (res *SellCargoCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sell-cargo"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/sell"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SellCargo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/sell"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSellCargoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "SellCargo", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSellCargoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShipRefine invokes ship-refine operation.
//
// Attempt to refine the raw materials on your ship. The request will only succeed if your ship is
// capable of refining at the time of the request. In order to be able to refine, a ship must have
// goods that can be refined and have installed a `Refinery` module that can refine it.
// When refining, 30 basic goods will be converted into 10 processed goods.
//
// POST /my/ships/{shipSymbol}/refine
func (c *Client) ShipRefine(ctx context.Context, request OptShipRefineReq, params ShipRefineParams) (*ShipRefineCreated, error) {
	res, err := c.sendShipRefine(ctx, request, params)
	return res, err
}

func (c *Client) sendShipRefine(ctx context.Context, request OptShipRefineReq, params ShipRefineParams) (res *ShipRefineCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ship-refine"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/refine"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ShipRefine",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/refine"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeShipRefineRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "ShipRefine", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeShipRefineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SiphonResources invokes siphon-resources operation.
//
// Siphon gases, such as hydrocarbon, from gas giants.
// The ship must be in orbit to be able to siphon and must have siphon mounts and a gas processor
// installed.
//
// POST /my/ships/{shipSymbol}/siphon
func (c *Client) SiphonResources(ctx context.Context, params SiphonResourcesParams) (*SiphonResourcesCreated, error) {
	res, err := c.sendSiphonResources(ctx, params)
	return res, err
}

func (c *Client) sendSiphonResources(ctx context.Context, params SiphonResourcesParams) (res *SiphonResourcesCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("siphon-resources"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/siphon"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SiphonResources",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/siphon"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "SiphonResources", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSiphonResourcesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SupplyConstruction invokes supply-construction operation.
//
// Supply a construction site with the specified good. Requires a waypoint with a property of
// `isUnderConstruction` to be true.
// The good must be in your ship's cargo. The good will be removed from your ship's cargo and added
// to the construction site's materials.
//
// POST /systems/{systemSymbol}/waypoints/{waypointSymbol}/construction/supply
func (c *Client) SupplyConstruction(ctx context.Context, request OptSupplyConstructionReq, params SupplyConstructionParams) (*SupplyConstructionCreated, error) {
	res, err := c.sendSupplyConstruction(ctx, request, params)
	return res, err
}

func (c *Client) sendSupplyConstruction(ctx context.Context, request OptSupplyConstructionReq, params SupplyConstructionParams) (res *SupplyConstructionCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("supply-construction"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/systems/{systemSymbol}/waypoints/{waypointSymbol}/construction/supply"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "SupplyConstruction",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/systems/"
	{
		// Encode "systemSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "systemSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SystemSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/waypoints/"
	{
		// Encode "waypointSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "waypointSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WaypointSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/construction/supply"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSupplyConstructionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "SupplyConstruction", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSupplyConstructionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TransferCargo invokes transfer-cargo operation.
//
// Transfer cargo between ships.
// The receiving ship must be in the same waypoint as the transferring ship, and it must able to hold
// the additional cargo after the transfer is complete. Both ships also must be in the same state,
// either both are docked or both are orbiting.
// The response body's cargo shows the cargo of the transferring ship after the transfer is complete.
//
// POST /my/ships/{shipSymbol}/transfer
func (c *Client) TransferCargo(ctx context.Context, request OptTransferCargoReq, params TransferCargoParams) (*TransferCargoOK, error) {
	res, err := c.sendTransferCargo(ctx, request, params)
	return res, err
}

func (c *Client) sendTransferCargo(ctx context.Context, request OptTransferCargoReq, params TransferCargoParams) (res *TransferCargoOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("transfer-cargo"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/transfer"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TransferCargo",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/transfer"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTransferCargoRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "TransferCargo", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTransferCargoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WarpShip invokes warp-ship operation.
//
// Warp your ship to a target destination in another system. The ship must be in orbit to use this
// function and must have the `Warp Drive` module installed. Warping will consume the necessary fuel
// from the ship's manifest.
// The returned response will detail the route information including the expected time of arrival.
// Most ship actions are unavailable until the ship has arrived at its destination.
//
// POST /my/ships/{shipSymbol}/warp
func (c *Client) WarpShip(ctx context.Context, request OptWarpShipReq, params WarpShipParams) (*WarpShipOK, error) {
	res, err := c.sendWarpShip(ctx, request, params)
	return res, err
}

func (c *Client) sendWarpShip(ctx context.Context, request OptWarpShipReq, params WarpShipParams) (res *WarpShipOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("warp-ship"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/my/ships/{shipSymbol}/warp"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "WarpShip",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/my/ships/"
	{
		// Encode "shipSymbol" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shipSymbol",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShipSymbol))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/warp"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeWarpShipRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:AgentToken"
			switch err := c.securityAgentToken(ctx, "WarpShip", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"AgentToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeWarpShipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
